{
  "hash": "c32056f26bf7700143b977e585d6f0ae",
  "result": {
    "markdown": "---\ntitle: \"About Designing & Prototyping shiny apps\"\nauthor: colin\ndate: \"2023-03-27\"\ndraft: true\n---\n\n\n> Prototyping first may help keep you from investing far too much time for marginal gains.\n\n> [The Art of UNIX Programming](http://www.catb.org/~esr/writings/taoup/html/ch01s06.html)\n\nCoders like coding, that's a golden truth.\nThe joy of taking an idea and bringing it to life by writing a bunch of characters in a text file is one of the most empowering feelings for anyone who loves engineering software.\n\nThis creates a bad habit for us all: jumping into coding as soon as we get the requirement.\nDoing that will not set the perfect condition for our `{shiny}` app, and for several reasons:\n\n- Specifications are by essence incomplete: no matter how precise we think they are, they are not enough.\n- Things can change during the development process.\n- Separation of concerns makes things easier to reason about, hence the importance of separating UI and backend validation.\n- Small, working prototypes can reveal misconceptions/misunderstandings, so the quicker we get a working prototype, the better\n\nIn this blog post, I'll present three packages from the golemverse that can you help make things easier for designing and prototyping.\n\n## `{shinidraw}`\n\n`{shinidraw}` is to bring the amazing [Exaclidraw](https://excalidraw.com/) to your R console.\n\nIt can be installed with\n\n```r\npak::pak(\"thinkr-open/shinidraw\")\n```\n\nExcalidraw is a whiteboard, in the browser, designed to sketch diagrams.\nIn our context (designing and prototyping), Excalidraw is the tool of choice for:\n\n- Concept Maps\n- Infrastructure schema\n\nAt [ThinkR](https://rtask.thinkr.fr/), we've been using it for a while now, during the design and prototype stage of any `{shiny}` project.\nWe use it for two purposes:\n\n- listing all the elements and interactions of the UI, server, and infrastructure elements (DB, deployment server...), so that at any moment of the project we can refer to this schema and know what we are developing.\n\n- as we build it with our clients, it is used as a tool to clarify our understanding of the project.\n\n### About `{shinidraw}`\n\nExcalidraw is awesome, and we've been using it for prototyping `{shiny}` apps for a while now.\nSo what was missing, and what does `{shinidraw}` brings to the table?\n\n### Projects\n\nWhen used in the browser, Excalidraw saves your drawings in your browser's local storage, and you can export and save them locally.\n\nWhen using `{shinidraw}`, you'll have a built-in project system, where the `.excalidraw` files are stored on the machine running the app.\n\nIf you work on an existing project, `{shinidraw}` will load the latest version of the `.excalidraw` file.\n\nHere are the commands you can use to manage your projects:\n\n```r\n# Create an empty, temp file (will not be saved)\nexcalidraw()\n\n# This will create a new project\nexcalidraw_new_project()\n\n# This will open an existing project\nexcalidraw_open_project(\"rr-2023\")\n\n# Simply open a file\nexcalidraw_open_file(\"inst/rect.excalidraw\")\n```\n\n### Autosaving\n\nThe app will auto-save your drawings at a given interval, so you don't have to worry about losing your work.\n\n### Example\n\nHere is a small example of what could be an infrastructure schema for an app:\n\n![](/img/fake_excalidraw.png)\n\n\n## UI prototyping with `{shinipsum}` and  `{fakir}`\n\nOne common joke in the software engineering world is that you can have the best backend algorithm ever, the first feedback you will get about your app is that the buttons' color should be blue.\nThis sounds like a fun discussion, but that's another golden truth of web apps: the user will always focus on the UI first, and you can ask for feedback about the backend as many times as you want, you'll always get feedback about the UI.\n\nThat's why we advise two things:\n\n- Separate the backend and the frontend, as much as you can, so that you can validate both separately (you can for example use [`{fusen}`](https://thinkr-open.github.io/fusen/) for developing the backend).\n- Prototype and validate an \"ipsum app\" before connecting the UI to a backend.\n\nTo build this prototype, the golemverse comes with the following packages:\n\n###  `{shinipsum}`\n\nThis package comes with a series of functions generating random UI elements so that you can use them in an ipsum app:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shinipsum)\nls(\"package:shinipsum\", pattern = \"random\") |>\ncat(sep = \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nrandom_DT\nrandom_dygraph\nrandom_ggplot\nrandom_ggplotly\nrandom_image\nrandom_print\nrandom_table\nrandom_text\n```\n:::\n:::\n\n\nHere is what it looks like in a `{shiny}` app:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(shinipsum)\nlibrary(DT)\nui <- fluidPage(\n  h2(\"A Random DT\"),\n  DTOutput(\"data_table\"),\n  h2(\"A Random Image\"),\n  plotOutput(\"image\", height = \"300px\"),\n  h2(\"A Random Plot\"),\n  plotOutput(\"plot\"),\n  h2(\"A Random Print\"),\n  verbatimTextOutput(\"print\"),\n  h2(\"A Random Table\"),\n  tableOutput(\"table\"),\n  h2(\"A Random Text\"),\n  tableOutput(\"text\")\n)\n\nserver <- function(input, output, session) {\n  output$data_table <- DT::renderDT({\n    random_DT(10, 5)\n  })\n  output$image <- renderImage({\n    random_image()\n  })\n  output$plot <- renderPlot({\n    random_ggplot()\n  })\n  output$print <- renderPrint({\n    random_print(\"model\")\n  })\n  output$table <- renderTable({\n    random_table(10, 5)\n  })\n  output$text <- renderText({\n    random_text(nwords = 50)\n  })\n}\nshinyApp(ui, server)\n```\n:::\n\n\nYou can install it with:\n\n```r\npak::pak(\"shinipsum\")\n```\n\n###  `{fakir}`\n\n`{shinipsum}` creates fake UI elements, `{fakir}` creates fake datasets.\n\nYou can install it with:\n\n```r\npak::pak(\"fakir\")\n```\n\nWith this package, we've aimed at mimicking \"real life\" datasets, so that you can use them in case you need to simulate inputs, models, backend elements, and others, before having access to DB and/or real datasets.\n\nHere is for example a fake dataset of visits on a website:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfakir::fake_visits()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 365 × 8\n   timestamp   year month   day  home about  blog contact\n * <date>     <dbl> <dbl> <int> <int> <int> <int>   <int>\n 1 2017-01-01  2017     1     1    NA    64   446     145\n 2 2017-01-02  2017     1     2   159   102   487     250\n 3 2017-01-03  2017     1     3    NA    59   479     433\n 4 2017-01-04  2017     1     4   123   202   601     109\n 5 2017-01-05  2017     1     5   362   162   311     378\n 6 2017-01-06  2017     1     6    NA   244   450     350\n 7 2017-01-07  2017     1     7    NA   298   343     232\n 8 2017-01-08  2017     1     8   461   121   389     122\n 9 2017-01-09  2017     1     9   337   171    NA     150\n10 2017-01-10  2017     1    10   155   151   515      NA\n# ℹ 355 more rows\n```\n:::\n:::\n\n\n## Further reading\n\n+ Engineering Production-Grade Shiny Apps:\n  - [Chapter 7 - Don’t Rush into Coding](https://engineering-shiny.org/dont-rush-into-coding.html)\n  - [Chapter 9 - Building an \"ipsum-app\"](https://engineering-shiny.org/building-ispum-app.html)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}